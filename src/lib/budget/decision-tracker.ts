/**
 * Decision Tracker
 *
 * Captures the reasoning behind every insight generated by the budget engine.
 * Provides a transparent audit trail: data → analysis → decision.
 */

import type { InsightReasoning, ReasoningStep, ReasoningDataPoint } from '@/types/budget';

// ═══════════════════════════════════════════════════════════════════════════
// REASONING BUILDER
// ═══════════════════════════════════════════════════════════════════════════

export class ReasoningBuilder {
    private steps: ReasoningStep[] = [];
    private confidence: number = 0.5;
    private alternatives: string[] = [];
    private dataSource: string = 'Transaction history';

    /** Record what data was used */
    addDataStep(title: string, detail: string, dataPoints?: ReasoningDataPoint[]): this {
        this.steps.push({ phase: 'data', title, detail, dataPoints });
        return this;
    }

    /** Record what analysis was performed */
    addAnalysisStep(title: string, detail: string, dataPoints?: ReasoningDataPoint[]): this {
        this.steps.push({ phase: 'analysis', title, detail, dataPoints });
        return this;
    }

    /** Record what decision was made */
    addDecisionStep(title: string, detail: string, dataPoints?: ReasoningDataPoint[]): this {
        this.steps.push({ phase: 'decision', title, detail, dataPoints });
        return this;
    }

    setConfidence(value: number): this {
        this.confidence = Math.max(0, Math.min(1, value));
        return this;
    }

    addAlternative(action: string): this {
        this.alternatives.push(action);
        return this;
    }

    setDataSource(description: string): this {
        this.dataSource = description;
        return this;
    }

    build(): InsightReasoning {
        return {
            steps: this.steps,
            confidence: this.confidence,
            alternativeActions: this.alternatives,
            dataSourceDescription: this.dataSource,
        };
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// HELPER UTILITIES
// ═══════════════════════════════════════════════════════════════════════════

/** Format a dollar amount for display in reasoning */
export function formatDollar(amount: number): string {
    return `$${Math.abs(amount).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
}

/** Format a percentage for display in reasoning */
export function formatPercent(value: number): string {
    return `${Math.abs(value).toFixed(1)}%`;
}

/** Build a monthly data summary string e.g. "Jan $258, Feb $280, Mar $315" */
export function formatMonthlySummary(data: Array<{ month: string; value: number }>): string {
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return data
        .map(d => {
            const monthIdx = parseInt(d.month.split('-')[1]) - 1;
            return `${monthNames[monthIdx]} ${formatDollar(d.value)}`;
        })
        .join(', ');
}

/** Simple linear regression returning slope and R² */
export function linearRegression(values: number[]): { slope: number; rSquared: number; intercept: number } {
    const n = values.length;
    if (n < 2) return { slope: 0, rSquared: 0, intercept: values[0] || 0 };

    const xMean = (n - 1) / 2;
    const yMean = values.reduce((a, b) => a + b, 0) / n;

    let ssXX = 0;
    let ssXY = 0;
    let ssTot = 0;

    for (let i = 0; i < n; i++) {
        const dx = i - xMean;
        const dy = values[i] - yMean;
        ssXX += dx * dx;
        ssXY += dx * dy;
        ssTot += dy * dy;
    }

    const slope = ssXX > 0 ? ssXY / ssXX : 0;
    const intercept = yMean - slope * xMean;

    // R²
    let ssRes = 0;
    for (let i = 0; i < n; i++) {
        const predicted = intercept + slope * i;
        ssRes += (values[i] - predicted) ** 2;
    }

    const rSquared = ssTot > 0 ? 1 - ssRes / ssTot : 0;

    return { slope, rSquared: Math.max(0, rSquared), intercept };
}

/** Compute basic statistics for an array of numbers */
export function computeStats(values: number[]): {
    mean: number;
    median: number;
    stdDev: number;
    min: number;
    max: number;
    q1: number;
    q3: number;
} {
    if (values.length === 0) {
        return { mean: 0, median: 0, stdDev: 0, min: 0, max: 0, q1: 0, q3: 0 };
    }

    const sorted = [...values].sort((a, b) => a - b);
    const n = sorted.length;
    const mean = sorted.reduce((a, b) => a + b, 0) / n;
    const median = n % 2 === 0 ? (sorted[n / 2 - 1] + sorted[n / 2]) / 2 : sorted[Math.floor(n / 2)];

    const variance = sorted.reduce((sum, v) => sum + (v - mean) ** 2, 0) / n;
    const stdDev = Math.sqrt(variance);

    const q1 = sorted[Math.floor(n * 0.25)];
    const q3 = sorted[Math.floor(n * 0.75)];

    return {
        mean,
        median,
        stdDev,
        min: sorted[0],
        max: sorted[n - 1],
        q1,
        q3,
    };
}
